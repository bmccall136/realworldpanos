<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Beating Student Proxy Sites Without Playing Whack-a-Mole (Custom Palo Alto App-ID)</title>
  <meta name="description" content="How we stopped student proxy frameworks by detecting their core JavaScript scaffolding with a custom Palo Alto Networks Application signature." />
  <link rel="canonical" href="/posts/proxy-avoidance/" />

  <style>
    :root {
      --text: #111;
      --muted: #666;
      --border: #e6e6e6;
      --bg: #fff;
      --codebg: #f7f7f7;
    }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font: 16px/1.6 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    .wrap {
      max-width: 980px;
      margin: 0 auto;
      padding: 28px 18px 70px;
    }
    header h1 {
      line-height: 1.2;
      margin: 0 0 10px;
      letter-spacing: -0.02em;
    }
    .meta {
      color: var(--muted);
      margin: 0 0 22px;
      font-size: 0.95rem;
    }
    .lead {
      font-size: 1.1rem;
      margin: 0 0 18px;
    }
    h2 {
      margin: 34px 0 10px;
      line-height: 1.25;
      letter-spacing: -0.01em;
    }
    p { margin: 12px 0; }
    ul { margin: 10px 0 10px 18px; }
    .callout {
      border: 1px solid var(--border);
      background: #fafafa;
      padding: 14px 16px;
      border-radius: 12px;
      margin: 18px 0;
    }
    figure {
      margin: 18px 0;
      border: 1px solid var(--border);
      border-radius: 14px;
      overflow: hidden;
      background: #fff;
    }
    figure img {
      display: block;
      width: 100%;
      height: auto;
    }
    figcaption {
      padding: 10px 12px;
      font-size: 0.95rem;
      color: var(--muted);
      border-top: 1px solid var(--border);
      background: #fcfcfc;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 14px;
      margin: 16px 0;
    }
    @media (max-width: 820px) {
      .grid { grid-template-columns: 1fr; }
    }
    code, pre {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    pre {
      background: var(--codebg);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px 14px;
      overflow: auto;
      font-size: 0.95rem;
    }
    .tags {
      color: var(--muted);
      margin-top: 22px;
      font-size: 0.95rem;
    }
    .footer-nav {
      margin-top: 34px;
      padding-top: 18px;
      border-top: 1px solid var(--border);
      color: var(--muted);
    }
    .footer-nav a { color: inherit; }
  </style>
</head>

<body>
  <article class="wrap">
    <header>
      <h1>Beating Student Proxy Sites Without Playing Whack-a-Mole</h1>
      <p class="meta">Custom Palo Alto Networks App-ID to disrupt common proxy frameworks</p>
      <p class="lead">
        Proxy sites like <b>Utopia, Lumi, Scramjet, Secured, Arsenic, Ultraviolet, Rammerhead</b> (and countless clones)
        pop up faster than you can block them. You take one down… two more appear. For a while, it felt like a game we were losing.
      </p>
    </header>

    <h2>Why URL filtering alone wasn’t cutting it</h2>
    <p>
      Traditional URL filtering often misses these because the sites are designed to look legitimate.
      They hide behind clean domains, rotate constantly, and are frequently miscategorized. Blocking by domain becomes a treadmill.
    </p>
    <p>
      The bigger issue: many of these “different” proxy sites are just different skins running the same underlying frameworks.
      So instead of chasing domains, the goal became simple:
    </p>

    <div class="callout">
      <b>Stop the engine, not the paint job.</b><br/>
      If the core proxy scaffolding never loads, the proxy never works — even if the site itself still opens.
    </div>

    <h2>The approach</h2>
    <p>
      I spent weeks (honestly months) breaking these sites down with browser developer tools, inspecting their network calls,
      and identifying what files the proxy frameworks consistently depended on.
    </p>
    <p>
      Across multiple families, a theme emerged: the same handful of JavaScript “skeleton” resources kept showing up —
      loaders, worker scripts, bundlers, and framework-specific paths.
    </p>

    <h2>The result: a custom Palo Alto Application + signatures</h2>
    <p>
      We built a custom Palo Alto Networks <b>Application</b> and a set of <b>signatures</b> that match those recurring proxy framework resources.
      It took iteration and refinement (and yes, we corrected a couple of false positives early on), but the end result has been solid.
    </p>

    <figure>
      <img src="/assets/img/1.png" alt="Palo Alto custom application configuration named Proxy Avoidance with risk and characteristics selected." />
      <figcaption>
        Custom Application: <b>Proxy Avoidance</b> — built to aggregate detection across multiple student proxy frameworks.
      </figcaption>
    </figure>

    <figure>
      <img src="/assets/img/2.png" alt="Signatures list in Palo Alto showing multiple proxy-related signature names (utopia, scram, lumi, rammer, secured, ws, uv, arsenic, wordplus)." />
      <figcaption>
        Signature set: individual “core” signatures per framework plus a shared catch-all signature for common paths.
      </figcaption>
    </figure>

    <h2>What we match (examples)</h2>
    <p>
      Below are examples of signature logic matching recurring framework resources.
      The key is consistency: these proxy frameworks can change domains all day long, but they still need their core scaffolding to run.
    </p>

    <div class="grid">
      <figure>
        <img src="/assets/img/3.png" alt="Signature conditions matching common WISP-related paths including wisp.js, bundle.js, and related loader endpoints." />
        <figcaption><b>proxy-wisp-core</b> — common WISP scaffolding paths (loader/bundle endpoints).</figcaption>
      </figure>

      <figure>
        <img src="/assets/img/4.png" alt="Signature conditions matching Utopia-related paths including games and JavaScript resources." />
        <figcaption><b>proxy-utopia-core</b> — recurring Utopia paths/resources used across clones.</figcaption>
      </figure>

      <figure>
        <img src="/assets/img/5.png" alt="Signature conditions matching Scramjet packaged assets and worker scripts such as scram/worker.js and related JS bundles." />
        <figcaption><b>proxy-scram-core</b> — Scramjet packaged assets and worker/bundle resources.</figcaption>
      </figure>

      <figure>
        <img src="/assets/img/6.png" alt="Signature conditions matching Lumi-related paths such as lumi and wv.bundle.js and wv.handler.js." />
        <figcaption><b>proxy-lumi-core</b> — Lumi framework resource paths (bundle/handler endpoints).</figcaption>
      </figure>

      <figure>
        <img src="/assets/img/7.png" alt="Signature conditions matching Wordplus JavaScript files such as loading.js, moresettings.js, frontpage.js, bundle.js." />
        <figcaption><b>proxy-wordplus-core</b> — Wordplus framework JS resources frequently reused.</figcaption>
      </figure>

      <figure>
        <img src="/assets/img/8.png" alt="Signature conditions matching Rammerhead dashboard resources including rh.js, rv, rh/worker.js and rammer paths." />
        <figcaption><b>proxy-rammer-dashboard</b> — Rammerhead dashboard + worker resources.</figcaption>
      </figure>

      <figure>
        <img src="/assets/img/9.png" alt="Signature conditions matching Secured framework JavaScript including messages.js and announcements.js." />
        <figcaption><b>proxy-secured-core</b> — Secured framework JS resources observed across deployments.</figcaption>
      </figure>

      <figure>
        <img src="/assets/img/10.png" alt="Signature conditions matching a shared proxy-websocket core including Upgrade: websocket header and common proxy paths like wisp, uv, and rammer assets." />
        <figcaption><b>proxy-ws-core</b> — shared WebSocket + common framework paths (useful across families).</figcaption>
      </figure>
    </div>

    <h2>What “success” looks like</h2>
    <p>
      This method doesn’t always produce a traditional block page — because we’re not necessarily blocking the site itself.
      Instead, we’re breaking the proxy’s ability to initialize.
    </p>
    <p>
      In practice, that’s exactly what we want: many of these proxy pages still exist, but they’re now <b>non-functional</b>
      because the core “engine” can’t load.
    </p>

    <div class="callout">
      <b>Takeaway:</b> You can’t win Whack-a-Mole by chasing domains forever.<br/>
      You win by identifying and disrupting the shared framework scaffolding those proxies depend on.
    </div>

    <h2>Closing thought</h2>
    <p>
      Students will keep trying “the latest and greatest,” and the names will keep changing.
      But as long as these proxy families keep reusing the same skeleton files, we can keep them broken.
    </p>

    <p class="tags">
      Tags: App-ID, Palo Alto Networks, K-12 Security, Proxy Avoidance, Web Proxy Frameworks, URL Filtering
    </p>

    <div class="footer-nav">
      Back to <a href="/posts/">Posts</a>
    </div>
  </article>
</body>
</html>
